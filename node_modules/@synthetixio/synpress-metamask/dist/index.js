import assert from 'assert';
import { z } from 'zod';
import { errors } from '@playwright/test';

// src/pages/OnboardingPage/actions/importWallet.ts

// src/utils/waitFor.ts
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var timeouts = [0, 20, 50, 100, 100, 500];
async function waitFor(action, timeout, shouldThrow = true) {
  let timeoutsSum = 0;
  let timeoutIndex = 0;
  let reachedTimeout = false;
  while (!reachedTimeout) {
    let nextTimeout = timeouts.at(Math.min(timeoutIndex++, timeouts.length - 1));
    if (timeoutsSum + nextTimeout > timeout) {
      nextTimeout = timeout - timeoutsSum;
      reachedTimeout = true;
    } else {
      timeoutsSum += nextTimeout;
    }
    await sleep(nextTimeout);
    const result = await action();
    if (result) {
      return result;
    }
  }
  if (shouldThrow) {
    throw new Error(`Timeout ${timeout}ms exceeded.`);
  }
  return false;
}

// src/utils/clickLocatorIfCondition.ts
async function clickLocatorIfCondition(locator, condition, timeout = 3e3) {
  const shouldClick = await waitFor(condition, timeout, false);
  if (shouldClick) {
    await locator.click();
  }
}

// src/utils/selectors/createDataTestSelector.ts
var createDataTestSelector = (dataTestId) => {
  if (dataTestId.includes(" ")) {
    throw new Error("[CreateDataTestSelector] dataTestId cannot contain spaces");
  }
  return `[data-testid="${dataTestId}"]`;
};

// src/pages/HomePage/selectors/settings.ts
var SettingsSidebarMenus = /* @__PURE__ */ ((SettingsSidebarMenus3) => {
  SettingsSidebarMenus3[SettingsSidebarMenus3["General"] = 1] = "General";
  SettingsSidebarMenus3[SettingsSidebarMenus3["Advanced"] = 2] = "Advanced";
  return SettingsSidebarMenus3;
})(SettingsSidebarMenus || {});
var sidebarMenu = (menu) => `.settings-page__content__tabs .tab-bar__tab.pointer:nth-of-type(${menu})`;
var resetAccount = {
  button: `${createDataTestSelector("advanced-setting-reset-account")} button`,
  confirmButton: ".modal .modal-container__footer button.btn-danger-primary"
};
var advanced = {
  // locator(showTestNetworksToggle).nth(0) -> Show conversion on test networks
  // locator(showTestNetworksToggle).nth(1) -> Show test networks
  resetAccount,
  showTestNetworksToggle: `${createDataTestSelector("advanced-setting-show-testnet-conversion")} .toggle-button`,
  dismissSecretRecoveryPhraseReminderToggle: ".settings-page__content-row:nth-of-type(11) .toggle-button"
};
var newNetworkFormContainer = ".networks-tab__add-network-form";
var newNetworkForm = {
  networkNameInput: `${newNetworkFormContainer} .form-field:nth-child(1) input`,
  rpcUrlInput: `${newNetworkFormContainer} .form-field:nth-child(2) input`,
  rpcUrlError: `${newNetworkFormContainer} .form-field:nth-child(2) .form-field__error`,
  chainIdInput: `${newNetworkFormContainer} .form-field:nth-child(3) input`,
  chainIdError: `${newNetworkFormContainer} .form-field:nth-child(3) .form-field__error`,
  symbolInput: `${createDataTestSelector("network-form-ticker")} input`,
  symbolError: createDataTestSelector("network-form-ticker-warning"),
  blockExplorerUrlInput: `${newNetworkFormContainer} .form-field:last-child input`,
  saveButton: `${newNetworkFormContainer} .networks-tab__add-network-form-footer button.btn-primary`
};
var networks = {
  addNetworkManuallyButton: `${createDataTestSelector("add-network-manually")}`,
  newNetworkForm
};
var settings_default = {
  SettingsSidebarMenus,
  sidebarMenu,
  advanced,
  networks
};

// src/pages/HomePage/selectors/index.ts
var accountMenuContainer = ".multichain-account-menu-popover";
var addNewAccountMenu = {
  accountNameInput: `${accountMenuContainer} input`,
  createButton: `${accountMenuContainer} button.mm-button-primary`
};
var importAccountMenu = {
  privateKeyInput: `${accountMenuContainer} input#private-key-box`,
  importButton: `${accountMenuContainer} ${createDataTestSelector("import-account-confirm-button")}`,
  error: `${accountMenuContainer} p.mm-form-text-field__help-text`
};
var addAccountMenu = {
  addAccountButton: `${accountMenuContainer} ${createDataTestSelector(
    "multichain-account-menu-popover-action-button"
  )}`,
  addNewAccountButton: `${accountMenuContainer} ${createDataTestSelector(
    "multichain-account-menu-popover-add-account"
  )}`,
  importAccountButton: `${accountMenuContainer} div.mm-box.mm-box--padding-4:nth-child(2) > div.mm-box:nth-child(2) > button`,
  addNewAccountMenu,
  importAccountMenu
};
var accountMenu = {
  accountButton: createDataTestSelector("account-menu-icon"),
  accountNames: `${accountMenuContainer} .multichain-account-menu-popover__list .multichain-account-list-item__account-name__button`,
  addAccountMenu
};
var threeDotsMenu = {
  threeDotsButton: createDataTestSelector("account-options-menu-button"),
  settingsButton: createDataTestSelector("global-menu-settings"),
  lockButton: createDataTestSelector("global-menu-lock")
};
var popoverContainer = ".popover-container";
var popover = {
  closeButton: `${popoverContainer} ${createDataTestSelector("popover-close")}`
};
var networkAddedPopover = {
  switchToNetworkButton: ".home__new-network-added button.btn-primary",
  dismissButton: ".home__new-network-added button.btn-secondary"
};
var newNetworkInfoPopover = {
  gotItButton: ".new-network-info__wrapper button.btn-primary"
};
var recoveryPhraseReminder = {
  gotItButton: ".recovery-phrase-reminder button.btn-primary"
};
var networkDropdownContainer = ".multichain-network-list-menu-content-wrapper";
var networkDropdown = {
  dropdownButton: createDataTestSelector("network-display"),
  closeDropdownButton: `${networkDropdownContainer} > section > div:nth-child(1) button`,
  networksList: `${networkDropdownContainer} .multichain-network-list-menu`,
  networks: `${networkDropdownContainer} .multichain-network-list-item p`,
  showTestNetworksToggle: `${networkDropdownContainer} > section > div > label.toggle-button`,
  addNetworkButton: `${networkDropdownContainer} div.mm-box.mm-box--padding-4 > button`,
  toggleOff: `${networkDropdownContainer} label.toggle-button.toggle-button--off`,
  toggleOn: `${networkDropdownContainer} label.toggle-button.toggle-button--on`
};
var tabContainer = ".tabs__content";
var activityTab = {
  activityTabButton: `${createDataTestSelector("home__activity-tab")}`,
  transactionsList: `${tabContainer} .transaction-list__transactions`,
  pendingQueuedTransactions: `${tabContainer} .transaction-list__pending-transactions .transaction-list-item .transaction-status-label--queued`,
  pendingUnapprovedTransactions: `${tabContainer} .transaction-list__pending-transactions .transaction-list-item .transaction-status-label--unapproved`,
  pendingApprovedTransactions: `${tabContainer} .transaction-list__pending-transactions .transaction-list-item .transaction-status-label--pending`,
  completedTransactions: `${tabContainer} .transaction-list__completed-transactions .transaction-list-item`
  /// ---- Unused Selectors ----
  // pendingTransactionsList: `${tabContainer} .transaction-list__pending-transactions`,
  // pendingTransactions: `${tabContainer} .transaction-list__pending-transactions .transaction-list-item`,
  // completedTransactionsList: `${tabContainer} .transaction-list__completed-transactions`,
};
var selectors_default = {
  logo: `button${createDataTestSelector("app-header-logo")}`,
  copyAccountAddressButton: createDataTestSelector("address-copy-button-text"),
  currentNetwork: `${createDataTestSelector("network-display")} span:nth-of-type(1)`,
  threeDotsMenu,
  settings: settings_default,
  activityTab,
  networkDropdown,
  accountMenu,
  recoveryPhraseReminder,
  popover,
  networkAddedPopover,
  newNetworkInfoPopover
};

// src/pages/HomePage/actions/popups/closePopover.ts
async function closePopover(page) {
  const closeButtonLocator = page.locator(selectors_default.popover.closeButton).first();
  await clickLocatorIfCondition(closeButtonLocator, () => closeButtonLocator.isVisible(), 1e3);
}

// src/pages/HomePage/actions/popups/closeRecoveryPhraseReminder.ts
async function closeRecoveryPhraseReminder(page) {
  const closeButtonLocator = page.locator(selectors_default.recoveryPhraseReminder.gotItButton);
  await clickLocatorIfCondition(closeButtonLocator, () => closeButtonLocator.isVisible(), 1e3);
}

// src/pages/HomePage/actions/popups/closeNewNetworkInfoPopover.ts
async function closeNewNetworkInfoPopover(page) {
  const gotItButtonLocator = page.locator(selectors_default.newNetworkInfoPopover.gotItButton);
  await clickLocatorIfCondition(gotItButtonLocator, () => gotItButtonLocator.isVisible(), 1e3);
}

// src/pages/HomePage/actions/popups/closeNetworkAddedPopover.ts
async function closeNetworkAddedPopover(page) {
  const switchNetworkButtonLocator = page.locator(selectors_default.networkAddedPopover.switchToNetworkButton);
  await clickLocatorIfCondition(switchNetworkButtonLocator, () => switchNetworkButtonLocator.isVisible(), 1e3);
}

// src/pages/HomePage/actions/lock.ts
async function lock(page) {
  await page.locator(selectors_default.threeDotsMenu.threeDotsButton).click();
  await page.locator(selectors_default.threeDotsMenu.lockButton).click();
}

// src/pages/HomePage/actions/importWalletFromPrivateKey.ts
async function importWalletFromPrivateKey(page, privateKey) {
  await page.locator(selectors_default.accountMenu.accountButton).click();
  await page.locator(selectors_default.accountMenu.addAccountMenu.addAccountButton).click();
  await page.locator(selectors_default.accountMenu.addAccountMenu.importAccountButton).click();
  await page.locator(selectors_default.accountMenu.addAccountMenu.importAccountMenu.privateKeyInput).fill(privateKey);
  const importButton = page.locator(selectors_default.accountMenu.addAccountMenu.importAccountMenu.importButton);
  await importButton.click();
  const isImportButtonHidden = await waitFor(() => importButton.isHidden(), 1e3, false);
  if (!isImportButtonHidden) {
    const errorText = await page.locator(selectors_default.accountMenu.addAccountMenu.importAccountMenu.error).textContent({
      timeout: 1e3
      // TODO: Extract & make configurable
    });
    throw new Error(`[ImportWalletFromPrivateKey] Importing failed due to error: ${errorText}`);
  }
}
async function allTextContents(locators) {
  const names = await Promise.all(locators.map((locator) => locator.textContent()));
  return names.map((name) => z.string().parse(name));
}

// src/pages/HomePage/actions/switchAccount.ts
async function switchAccount(page, accountName) {
  await page.locator(selectors_default.accountMenu.accountButton).click();
  const accountNamesLocators = await page.locator(selectors_default.accountMenu.accountNames).all();
  const accountNames = await allTextContents(accountNamesLocators);
  const seekedAccountNames = accountNames.filter((name) => name.toLocaleLowerCase() === accountName.toLocaleLowerCase());
  if (seekedAccountNames.length === 0) {
    throw new Error(`[SwitchAccount] Account with name ${accountName} not found`);
  }
  const accountIndex = accountNames.indexOf(seekedAccountNames[0]);
  await accountNamesLocators[accountIndex].click();
}

// src/utils/toggle.ts
async function toggle(toggleLocator) {
  const classes = await toggleLocator.getAttribute("class", { timeout: 3e3 });
  if (!classes) {
    throw new Error("[ToggleShowTestNetworks] Toggle class returned null");
  }
  const isOn = classes.includes("toggle-button--on");
  await toggleLocator.click();
  const waitForAction = async () => {
    const classes2 = await toggleLocator.getAttribute("class");
    if (!classes2) {
      throw new Error("[ToggleShowTestNetworks] Toggle class returned null inside waitFor");
    }
    if (isOn) {
      return classes2.includes("toggle-button--off");
    }
    return classes2.includes("toggle-button--on");
  };
  await waitFor(waitForAction, 3e3, true);
}

// src/pages/HomePage/actions/settings.ts
async function openSettings(page) {
  await page.locator(selectors_default.threeDotsMenu.threeDotsButton).click();
  await page.locator(selectors_default.threeDotsMenu.settingsButton).click();
}
async function openSidebarMenu(page, menu) {
  await page.locator(selectors_default.settings.sidebarMenu(menu)).click();
}
async function resetAccount2(page) {
  const buttonSelector = `[data-testid="advanced-setting-reset-account"] button`;
  const confirmButtonSelector = ".modal .modal-container__footer button.btn-danger-primary";
  await page.locator(buttonSelector).click();
  await page.locator(confirmButtonSelector).click();
}
async function toggleDismissSecretRecoveryPhraseReminder(page) {
  const toggleLocator = page.locator(selectors_default.settings.advanced.dismissSecretRecoveryPhraseReminderToggle);
  await toggle(toggleLocator);
}
var advanced2 = {
  resetAccount: resetAccount2,
  toggleDismissSecretRecoveryPhraseReminder
};
var settings = {
  openSettings,
  openSidebarMenu,
  advanced: advanced2
};

// src/pages/HomePage/actions/switchNetwork.ts
async function openTestnetSection(page) {
  const toggleButtonLocator = page.locator(selectors_default.networkDropdown.showTestNetworksToggle);
  const classes = await toggleButtonLocator.getAttribute("class");
  if (classes?.includes("toggle-button--off")) {
    await toggleButtonLocator.click();
    await page.locator(selectors_default.networkDropdown.toggleOn).isChecked();
  }
}
async function switchNetwork(page, networkName, includeTestNetworks) {
  await page.locator(selectors_default.networkDropdown.dropdownButton).click();
  if (includeTestNetworks) {
    await openTestnetSection(page);
  }
  const networkLocators = await page.locator(selectors_default.networkDropdown.networks).all();
  const networkNames = await allTextContents(networkLocators);
  const seekedNetworkNameIndex = networkNames.findIndex(
    (name) => name.toLocaleLowerCase() === networkName.toLocaleLowerCase()
  );
  const seekedNetworkLocator = seekedNetworkNameIndex >= 0 && networkLocators[seekedNetworkNameIndex];
  if (!seekedNetworkLocator) {
    throw new Error(`[SwitchNetwork] Network with name ${networkName} not found`);
  }
  await seekedNetworkLocator.click();
  await closeRecoveryPhraseReminder(page);
}
var Network = z.object({
  name: z.string(),
  rpcUrl: z.string(),
  chainId: z.number(),
  symbol: z.string(),
  blockExplorerUrl: z.string().optional()
});
async function addNetwork(page, network2) {
  const { name, rpcUrl, chainId, symbol, blockExplorerUrl } = Network.parse(network2);
  await page.locator(selectors_default.networkDropdown.dropdownButton).click();
  await page.locator(selectors_default.networkDropdown.addNetworkButton).click();
  await page.locator(selectors_default.settings.networks.addNetworkManuallyButton).click();
  await page.locator(selectors_default.settings.networks.newNetworkForm.networkNameInput).fill(name);
  await page.locator(selectors_default.settings.networks.newNetworkForm.rpcUrlInput).fill(rpcUrl);
  const rpcUrlErrorLocator = page.locator(selectors_default.settings.networks.newNetworkForm.rpcUrlError);
  if (await waitFor(() => rpcUrlErrorLocator.isVisible(), 1e3, false)) {
    const rpcUrlErrorText = await rpcUrlErrorLocator.textContent({
      timeout: 1e3
    });
    throw new Error(`[AddNetwork] RPC URL error: ${rpcUrlErrorText}`);
  }
  await page.locator(selectors_default.settings.networks.newNetworkForm.chainIdInput).fill(chainId.toString());
  const chainIdErrorLocator = page.locator(selectors_default.settings.networks.newNetworkForm.chainIdError);
  if (await waitFor(() => chainIdErrorLocator.isVisible(), 1e3, false)) {
    const chainIdErrorText = await chainIdErrorLocator.textContent({
      timeout: 1e3
    });
    throw new Error(`[AddNetwork] Chain ID error: ${chainIdErrorText}`);
  }
  await page.locator(selectors_default.settings.networks.newNetworkForm.symbolInput).fill(symbol);
  await waitFor(
    async () => page.locator(selectors_default.settings.networks.newNetworkForm.symbolError).isVisible(),
    1e3,
    false
  );
  if (blockExplorerUrl) {
    await page.locator(selectors_default.settings.networks.newNetworkForm.blockExplorerUrlInput).fill(blockExplorerUrl);
  }
  await page.locator(selectors_default.settings.networks.newNetworkForm.saveButton).click();
  await closeNetworkAddedPopover(page);
  await closeNewNetworkInfoPopover(page);
}

// src/pages/HomePage/actions/toggleShowTestNetworks.ts
async function toggleShowTestNetworks(page) {
  await page.locator(selectors_default.networkDropdown.dropdownButton).click();
  await toggle(page.locator(selectors_default.networkDropdown.showTestNetworksToggle));
}

// src/pages/HomePage/actions/addNewAccount.ts
async function addNewAccount(page, accountName) {
  if (accountName.length === 0) {
    throw new Error("[AddNewAccount] Account name cannot be an empty string");
  }
  await page.locator(selectors_default.accountMenu.accountButton).click();
  await page.locator(selectors_default.accountMenu.addAccountMenu.addAccountButton).click();
  await page.locator(selectors_default.accountMenu.addAccountMenu.addNewAccountButton).click();
  await page.locator(selectors_default.accountMenu.addAccountMenu.addNewAccountMenu.accountNameInput).fill(accountName);
  await page.locator(selectors_default.accountMenu.addAccountMenu.addNewAccountMenu.createButton).click();
}

// src/pages/HomePage/actions/transactionDetails.ts
var openTransactionDetails = async (page, txIndex) => {
  await page.locator(selectors_default.activityTab.activityTabButton).click();
  const visibleTxs = await page.locator(selectors_default.activityTab.completedTransactions).count();
  if (txIndex >= visibleTxs) {
    throw new Error(
      `[OpenTransactionDetails] Transaction with index ${txIndex} is not visible. There are only ${visibleTxs} transactions visible.`
    );
  }
  await page.locator(selectors_default.activityTab.completedTransactions).nth(txIndex).click();
  await waitFor(() => page.locator(selectors_default.popover.closeButton).isVisible(), 3e3);
};
var closeTransactionDetails = async (page) => {
  await page.locator(selectors_default.popover.closeButton).click();
};
var transactionDetails = {
  open: openTransactionDetails,
  close: closeTransactionDetails
};

// src/pages/OnboardingPage/selectors/analyticsPage.ts
var analyticsPage_default = {
  optIn: createDataTestSelector("metametrics-i-agree"),
  optOut: createDataTestSelector("metametrics-no-thanks")
};

// src/pages/OnboardingPage/selectors/getStartedPage.ts
var getStartedPage_default = {
  termsOfServiceCheckbox: createDataTestSelector("onboarding-terms-checkbox"),
  createNewWallet: createDataTestSelector("onboarding-create-wallet"),
  importWallet: createDataTestSelector("onboarding-import-wallet")
};

// src/pages/OnboardingPage/selectors/pinExtensionPage.ts
var pinExtensionPage_default = {
  nextButton: createDataTestSelector("pin-extension-next"),
  confirmButton: createDataTestSelector("pin-extension-done")
};

// src/pages/OnboardingPage/selectors/secretRecoveryPhrasePage.ts
var recoveryStep = {
  selectNumberOfWordsDropdown: ".import-srp__number-of-words-dropdown > .dropdown__select",
  selectNumberOfWordsOption: (option) => `${option}`,
  secretRecoveryPhraseWord: (index) => createDataTestSelector(`import-srp__srp-word-${index}`),
  confirmSecretRecoveryPhraseButton: createDataTestSelector("import-srp-confirm"),
  error: ".mm-banner-alert.import-srp__srp-error div"
};
var passwordStep = {
  passwordInput: createDataTestSelector("create-password-new"),
  confirmPasswordInput: createDataTestSelector("create-password-confirm"),
  acceptTermsCheckbox: createDataTestSelector("create-password-terms"),
  importWalletButton: createDataTestSelector("create-password-import"),
  error: `${createDataTestSelector("create-password-new")} + h6 > span > span`
};
var secretRecoveryPhrasePage_default = {
  recoveryStep,
  passwordStep
};

// src/pages/OnboardingPage/selectors/walletCreationSuccessPage.ts
var walletCreationSuccessPage_default = {
  confirmButton: createDataTestSelector("onboarding-complete-done")
};

// src/pages/OnboardingPage/selectors/index.ts
var selectors_default2 = {
  // Initial Welcome Page
  GetStartedPageSelectors: getStartedPage_default,
  // 2nd Page
  AnalyticsPageSelectors: analyticsPage_default,
  // 3rd Page with two steps:
  // - Input Secret Recovery Phrase
  // - Create Password
  SecretRecoveryPhrasePageSelectors: secretRecoveryPhrasePage_default,
  // 4th Page
  WalletCreationSuccessPageSelectors: walletCreationSuccessPage_default,
  // 5th Page
  PinExtensionPageSelectors: pinExtensionPage_default
};

// src/pages/OnboardingPage/actions/helpers/confirmSecretRecoveryPhrase.ts
var StepSelectors = selectors_default2.SecretRecoveryPhrasePageSelectors.recoveryStep;
async function confirmSecretRecoveryPhrase(page, seedPhrase) {
  const seedPhraseWords = seedPhrase.split(" ");
  const seedPhraseLength = seedPhraseWords.length;
  await page.locator(StepSelectors.selectNumberOfWordsDropdown).selectOption(StepSelectors.selectNumberOfWordsOption(seedPhraseLength));
  for (const [index, word] of seedPhraseWords.entries()) {
    await page.locator(StepSelectors.secretRecoveryPhraseWord(index)).fill(word);
  }
  const confirmSRPButton = page.locator(StepSelectors.confirmSecretRecoveryPhraseButton);
  if (await confirmSRPButton.isDisabled()) {
    const errorText = await page.locator(StepSelectors.error).textContent({
      timeout: 1e3
    });
    throw new Error(`[ConfirmSecretRecoveryPhrase] Invalid seed phrase. Error from MetaMask: ${errorText}`);
  }
  await confirmSRPButton.click();
}

// src/pages/OnboardingPage/actions/helpers/createPassword.ts
var StepSelectors2 = selectors_default2.SecretRecoveryPhrasePageSelectors.passwordStep;
async function createPassword(page, password) {
  await page.locator(StepSelectors2.passwordInput).fill(password);
  await page.locator(StepSelectors2.confirmPasswordInput).fill(password);
  await page.locator(StepSelectors2.acceptTermsCheckbox).click();
  const importWalletButton = page.locator(StepSelectors2.importWalletButton);
  if (await importWalletButton.isDisabled()) {
    const errorText = await page.locator(StepSelectors2.error).textContent({
      timeout: 1e3
    });
    throw new Error(`[CreatePassword] Invalid password. Error from MetaMask: ${errorText}`);
  }
  await importWalletButton.click();
}

// src/pages/OnboardingPage/actions/importWallet.ts
async function importWallet(page, seedPhrase, password) {
  await page.locator(selectors_default2.GetStartedPageSelectors.termsOfServiceCheckbox).click();
  await page.locator(selectors_default2.GetStartedPageSelectors.importWallet).click();
  await page.locator(selectors_default2.AnalyticsPageSelectors.optOut).click();
  await confirmSecretRecoveryPhrase(page, seedPhrase);
  await createPassword(page, password);
  await page.locator(selectors_default2.WalletCreationSuccessPageSelectors.confirmButton).click();
  await page.locator(selectors_default2.PinExtensionPageSelectors.nextButton).click();
  await page.locator(selectors_default2.PinExtensionPageSelectors.confirmButton).click();
  await closePopover(page);
  await verifyImportedWallet(page);
}
async function verifyImportedWallet(page) {
  const accountAddress = await page.locator(selectors_default.copyAccountAddressButton).textContent();
  assert.strictEqual(
    accountAddress?.startsWith("0x"),
    true,
    new Error(
      [
        `Incorrect state after importing the seed phrase. Account address is expected to start with "0x", but got "${accountAddress}" instead.`,
        "Note: Try to re-run the cache creation. This is a known but rare error where MetaMask hangs during the onboarding process. If it persists, please file an issue on GitHub."
      ].join("\n")
    )
  );
}

// src/pages/OnboardingPage/page.ts
var OnboardingPage = class {
  static selectors = selectors_default2;
  selectors = selectors_default2;
  page;
  constructor(page) {
    this.page = page;
  }
  async importWallet(seedPhrase, password) {
    return await importWallet(this.page, seedPhrase, password);
  }
};

// src/pages/CrashPage/selectors/index.ts
var container = "section.error-page";
var selectors_default3 = {
  header: `${container} > .error-page__header`,
  errors: `${container} > .error-page__details li`
};

// src/pages/CrashPage/page.ts
var CrashPage = class {
  static selectors = selectors_default3;
  selectors = selectors_default3;
};

// src/selectors/loading/index.ts
var LoadingSelectors = {
  spinner: ".spinner"
};

// src/utils/waitForSpinnerToVanish.ts
var DEFAULT_TIMEOUT = 1e4;
async function waitForSpinnerToVanish(page) {
  await page.locator(LoadingSelectors.spinner).waitFor({
    state: "hidden",
    timeout: DEFAULT_TIMEOUT
  });
}

// src/pages/LockPage/selectors/index.ts
var selectors_default4 = {
  passwordInput: createDataTestSelector("unlock-password"),
  submitButton: createDataTestSelector("unlock-submit")
};

// src/pages/LockPage/actions/unlock.ts
async function unlock(page, password) {
  await page.locator(selectors_default4.passwordInput).fill(password);
  await page.locator(selectors_default4.submitButton).click();
  await waitForSpinnerToVanish(page);
}

// src/pages/LockPage/page.ts
var LockPage = class {
  static selectors = selectors_default4;
  selectors = selectors_default4;
  page;
  constructor(page) {
    this.page = page;
  }
  async unlock(password) {
    await unlock(this.page, password);
  }
};

// src/pages/HomePage/page.ts
var HomePage = class {
  static selectors = selectors_default;
  selectors = selectors_default;
  page;
  constructor(page) {
    this.page = page;
  }
  async goBackToHomePage() {
    await this.page.locator(selectors_default.logo).click();
  }
  async lock() {
    await lock(this.page);
  }
  async addNewAccount(accountName) {
    await addNewAccount(this.page, accountName);
  }
  async importWalletFromPrivateKey(privateKey) {
    await importWalletFromPrivateKey(this.page, privateKey);
  }
  async switchAccount(accountName) {
    await switchAccount(this.page, accountName);
  }
  async openSettings() {
    await settings.openSettings(this.page);
  }
  async openSidebarMenu(menu) {
    await settings.openSidebarMenu(this.page, menu);
  }
  async toggleShowTestNetworks() {
    await toggleShowTestNetworks(this.page);
  }
  async resetAccount() {
    await settings.advanced.resetAccount(this.page);
  }
  async toggleDismissSecretRecoveryPhraseReminder() {
    await settings.advanced.toggleDismissSecretRecoveryPhraseReminder(this.page);
  }
  async switchNetwork(networkName, isTestnet) {
    await switchNetwork(this.page, networkName, isTestnet);
  }
  async addNetwork(network2) {
    await addNetwork(this.page, network2);
  }
  async openTransactionDetails(txIndex) {
    await transactionDetails.open(this.page, txIndex);
  }
  async closeTransactionDetails() {
    await transactionDetails.close(this.page);
  }
};

// src/utils/getNotificationPageAndWaitForLoad.ts
async function getNotificationPageAndWaitForLoad(context, extensionId) {
  const notificationPageUrl = `chrome-extension://${extensionId}/notification.html`;
  const isNotificationPage = (page) => page.url().includes(notificationPageUrl);
  let notificationPage = context.pages().find(isNotificationPage);
  if (!notificationPage) {
    notificationPage = await context.waitForEvent("page", { predicate: isNotificationPage });
  }
  await notificationPage.setViewportSize({
    width: 360,
    height: 592
  });
  await notificationPage.waitForLoadState("load");
  return notificationPage;
}

// src/pages/NotificationPage/selectors/actionFooter.ts
var actionFooter_default = {
  confirmActionButton: `.page-container__footer ${createDataTestSelector("page-container-footer-next")}`,
  rejectActionButton: `.page-container__footer ${createDataTestSelector("page-container-footer-cancel")}`
};

// src/pages/NotificationPage/selectors/connectPage.ts
var connectPage_default = {
  accountOption: ".choose-account-list .choose-account-list__list .choose-account-list__account",
  accountCheckbox: "input.choose-account-list__list-check-box"
};

// src/pages/NotificationPage/selectors/networkPage.ts
var addNetwork2 = {
  approveButton: ".confirmation-footer__actions button.btn-primary",
  cancelButton: ".confirmation-footer__actions button.btn-secondary"
};
var switchNetwork2 = {
  switchNetworkButton: ".confirmation-footer__actions button.btn-primary",
  cancelButton: ".confirmation-footer__actions button.btn-secondary"
};
var networkPage_default = {
  addNetwork: addNetwork2,
  switchNetwork: switchNetwork2
};

// src/pages/NotificationPage/selectors/permissionPage.ts
var approve = {
  maxButton: createDataTestSelector("custom-spending-cap-max-button"),
  customSpendingCapInput: createDataTestSelector("custom-spending-cap-input")
};
var permissionPage_default = {
  approve
};

// src/pages/NotificationPage/selectors/signaturePage.ts
var simpleMessage = {
  signButton: `.request-signature__footer ${createDataTestSelector("request-signature__sign")}`,
  rejectButton: ".request-signature__footer button.btn-secondary"
};
var structuredMessage = {
  scrollDownButton: `.signature-request-message ${createDataTestSelector("signature-request-scroll-button")}`,
  signButton: `.signature-request-footer ${createDataTestSelector("signature-sign-button")}`,
  rejectButton: `.signature-request-footer ${createDataTestSelector("signature-cancel-button")}`
};
var signaturePage_default = {
  simpleMessage,
  structuredMessage
};

// src/pages/NotificationPage/selectors/transactionPage.ts
var advancedGasFeeMenu = {
  maxBaseFeeInput: createDataTestSelector("base-fee-input"),
  priorityFeeInput: createDataTestSelector("priority-fee-input"),
  gasLimitEditButton: createDataTestSelector("advanced-gas-fee-edit"),
  gasLimitInput: createDataTestSelector("gas-limit-input"),
  gasLimitError: `div:has(> ${createDataTestSelector("gas-limit-input")}) + .form-field__error`,
  saveButton: ".popover-footer > button.btn-primary"
};
var lowGasFee = {
  button: createDataTestSelector("edit-gas-fee-item-low"),
  maxFee: `${createDataTestSelector("edit-gas-fee-item-low")} .edit-gas-item__fee-estimate`
};
var marketGasFee = {
  button: createDataTestSelector("edit-gas-fee-item-medium"),
  maxFee: `${createDataTestSelector("edit-gas-fee-item-medium")} .edit-gas-item__fee-estimate`
};
var aggressiveGasFee = {
  button: createDataTestSelector("edit-gas-fee-item-high"),
  maxFee: `${createDataTestSelector("edit-gas-fee-item-high")} .edit-gas-item__fee-estimate`
};
var editGasFeeMenu = {
  editGasFeeButton: createDataTestSelector("edit-gas-fee-icon"),
  editGasFeeButtonToolTip: ".edit-gas-fee-button .info-tooltip",
  lowGasFee,
  marketGasFee,
  aggressiveGasFee,
  siteSuggestedGasFeeButton: createDataTestSelector("edit-gas-fee-item-dappSuggested"),
  advancedGasFeeButton: createDataTestSelector("edit-gas-fee-item-custom"),
  advancedGasFeeMenu
};
var nftApproveAllConfirmationPopup = {
  approveButton: ".set-approval-for-all-warning__content button.set-approval-for-all-warning__footer__approve-button"
};
var transactionPage_default = {
  editGasFeeMenu,
  nftApproveAllConfirmationPopup
};

// src/pages/NotificationPage/selectors/index.ts
var selectors_default5 = {
  ActionFooter: actionFooter_default,
  ConnectPage: connectPage_default,
  SignaturePage: signaturePage_default,
  NetworkPage: networkPage_default,
  PermissionPage: permissionPage_default,
  TransactionPage: transactionPage_default
};

// src/pages/NotificationPage/actions/connectToDapp.ts
async function selectAccounts(accountsToSelect, accountLocators, availableAccountNames) {
  for (const account of accountsToSelect) {
    const accountNameIndex = availableAccountNames.findIndex((name) => name.startsWith(account));
    if (accountNameIndex < 0)
      throw new Error(`[ConnectToDapp] Account with name ${account} not found`);
    await accountLocators[accountNameIndex]?.locator(selectors_default5.ConnectPage.accountCheckbox).check();
  }
}
async function connectMultipleAccounts(notificationPage, accounts) {
  await notificationPage.locator(selectors_default5.ConnectPage.accountOption).locator(selectors_default5.ConnectPage.accountCheckbox).last().setChecked(false);
  const accountLocators = await notificationPage.locator(selectors_default5.ConnectPage.accountOption).all();
  const accountNames = await allTextContents(accountLocators);
  await selectAccounts(accounts, accountLocators, accountNames);
}
async function confirmConnection(notificationPage) {
  await notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton).click();
  await notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton).click();
}
async function connectToDapp(notificationPage, accounts) {
  if (accounts && accounts.length > 0) {
    await connectMultipleAccounts(notificationPage, accounts);
  }
  await confirmConnection(notificationPage);
}

// src/pages/NotificationPage/actions/signSimpleMessage.ts
var signMessage = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton).click();
};
var rejectMessage = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.ActionFooter.rejectActionButton).click();
};
var signSimpleMessage = {
  sign: signMessage,
  reject: rejectMessage
};

// src/pages/NotificationPage/actions/signStructuredMessage.ts
var signMessage2 = async (notificationPage) => {
  const scrollDownButton = notificationPage.locator(selectors_default5.SignaturePage.structuredMessage.scrollDownButton);
  const signButton = notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton);
  while (await signButton.isDisabled()) {
    await scrollDownButton.click();
  }
  await signButton.click();
};
var rejectMessage2 = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.ActionFooter.rejectActionButton).click();
};
var signStructuredMessage = {
  sign: signMessage2,
  reject: rejectMessage2
};
var GasSetting = z.union([
  z.literal("low"),
  z.literal("market"),
  z.literal("aggressive"),
  z.literal("site"),
  z.object({
    maxBaseFee: z.number(),
    priorityFee: z.number(),
    // TODO: Add gasLimit range validation.
    gasLimit: z.number().optional()
  }).superRefine(({ maxBaseFee, priorityFee }, ctx) => {
    if (priorityFee > maxBaseFee) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Max base fee cannot be lower than priority fee",
        path: ["MetaMask", "confirmTransaction", "gasSetting", "maxBaseFee"]
      });
    }
  })
]);
var confirmTransaction = async (notificationPage, options) => {
  const gasSetting = GasSetting.parse(options);
  const handleNftSetApprovalForAll = async (page) => {
    try {
      const nftApproveButtonLocator = page.locator(
        selectors_default5.TransactionPage.nftApproveAllConfirmationPopup.approveButton
      );
      const isNfTPopupHidden = await waitFor(() => nftApproveButtonLocator.isHidden(), 3e3, false);
      if (!isNfTPopupHidden) {
        await nftApproveButtonLocator.click();
      }
    } catch (e) {
      if (page.isClosed()) {
        return;
      }
      throw new Error(`Failed to handle NFT setApprovalForAll popup: ${e}`);
    }
  };
  if (gasSetting === "site") {
    await notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton).click();
    await handleNftSetApprovalForAll(notificationPage);
    return;
  }
  await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.editGasFeeButton).click();
  const estimationNotAvailableErrorMessage = (gasSetting2) => `[ConfirmTransaction] Estimated fee is not available for the "${gasSetting2}" gas setting. By default, MetaMask would use the "site" gas setting in this case, however, this is not YOUR intention.`;
  const handleLowMediumOrAggressiveGasSetting = async (gasSetting2, selectors) => {
    if (await notificationPage.locator(selectors.maxFee).textContent() === "--") {
      throw new Error(estimationNotAvailableErrorMessage(gasSetting2));
    }
    await notificationPage.locator(selectors.button).click();
  };
  if (gasSetting === "low") {
    await handleLowMediumOrAggressiveGasSetting(gasSetting, selectors_default5.TransactionPage.editGasFeeMenu.lowGasFee);
  } else if (gasSetting === "market") {
    await handleLowMediumOrAggressiveGasSetting(gasSetting, selectors_default5.TransactionPage.editGasFeeMenu.marketGasFee);
  } else if (gasSetting === "aggressive") {
    await handleLowMediumOrAggressiveGasSetting(gasSetting, selectors_default5.TransactionPage.editGasFeeMenu.aggressiveGasFee);
  } else {
    await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeButton).click();
    await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.maxBaseFeeInput).fill("");
    await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.maxBaseFeeInput).fill(gasSetting.maxBaseFee.toString());
    await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.priorityFeeInput).fill("");
    await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.priorityFeeInput).fill(gasSetting.priorityFee.toString());
    if (gasSetting.gasLimit) {
      await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.gasLimitEditButton).click();
      await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.gasLimitInput).fill("");
      await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.gasLimitInput).fill(gasSetting.gasLimit.toString());
      const gasLimitErrorLocator = notificationPage.locator(
        selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.gasLimitError
      );
      const isGasLimitErrorHidden = await waitFor(() => gasLimitErrorLocator.isHidden(), 1e3, false);
      if (!isGasLimitErrorHidden) {
        const errorText = await gasLimitErrorLocator.textContent({
          timeout: 1e3
          // TODO: Extract & make configurable
        });
        throw new Error(`[ConfirmTransaction] Invalid gas limit: ${errorText}`);
      }
    }
    await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.advancedGasFeeMenu.saveButton).click();
  }
  const waitForAction = async () => {
    const isTooltipVisible = await notificationPage.locator(selectors_default5.TransactionPage.editGasFeeMenu.editGasFeeButtonToolTip).isVisible();
    return !isTooltipVisible;
  };
  await waitFor(waitForAction, 3e3, true);
  await notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton).click();
  await handleNftSetApprovalForAll(notificationPage);
};
var confirmTransactionAndWaitForMining = async (walletPage, notificationPage, options) => {
  await walletPage.locator(selectors_default.activityTab.activityTabButton).click();
  const waitForUnapprovedTxs = async () => {
    const unapprovedTxs = await walletPage.locator(selectors_default.activityTab.pendingUnapprovedTransactions).count();
    return unapprovedTxs !== 0;
  };
  const newTxsFound = await waitFor(waitForUnapprovedTxs, 3e4, false);
  if (!newTxsFound) {
    throw new Error("No new pending transactions found in 30s");
  }
  await confirmTransaction(notificationPage, options);
  const waitForMining = async () => {
    const unapprovedTxs = await walletPage.locator(selectors_default.activityTab.pendingUnapprovedTransactions).count();
    const pendingTxs = await walletPage.locator(selectors_default.activityTab.pendingApprovedTransactions).count();
    const queuedTxs = await walletPage.locator(selectors_default.activityTab.pendingQueuedTransactions).count();
    return unapprovedTxs === 0 && pendingTxs === 0 && queuedTxs === 0;
  };
  const allTxsMined = await waitFor(waitForMining, 12e4, false);
  if (!allTxsMined) {
    throw new Error("All pending and queued transactions were not mined in 120s");
  }
};
var rejectTransaction = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.ActionFooter.rejectActionButton).click();
};
var transaction = {
  confirm: confirmTransaction,
  reject: rejectTransaction,
  confirmAndWaitForMining: confirmTransactionAndWaitForMining
};

// src/pages/NotificationPage/actions/approvePermission.ts
var editTokenPermission = async (notificationPage, customSpendLimit) => {
  if (customSpendLimit === "max") {
    await notificationPage.locator(selectors_default5.PermissionPage.approve.maxButton).click();
    return;
  }
  await notificationPage.locator(selectors_default5.PermissionPage.approve.customSpendingCapInput).fill(customSpendLimit.toString());
};
var approveTokenPermission = async (notificationPage, gasSetting) => {
  await notificationPage.locator(selectors_default5.ActionFooter.confirmActionButton).click();
  await transaction.confirm(notificationPage, gasSetting);
};
var rejectTokenPermission = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.ActionFooter.rejectActionButton).click();
};
var approvePermission = {
  editTokenPermission,
  approve: approveTokenPermission,
  reject: rejectTokenPermission
};

// src/pages/NotificationPage/actions/network.ts
var approveNewNetwork = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.NetworkPage.addNetwork.approveButton).click();
};
var rejectNewNetwork = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.NetworkPage.addNetwork.cancelButton).click();
};
var approveSwitchNetwork = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.NetworkPage.switchNetwork.switchNetworkButton).click();
};
var rejectSwitchNetwork = async (notificationPage) => {
  await notificationPage.locator(selectors_default5.NetworkPage.switchNetwork.cancelButton).click();
};
var network = {
  approveNewNetwork,
  rejectNewNetwork,
  approveSwitchNetwork,
  rejectSwitchNetwork
};

// src/pages/NotificationPage/page.ts
var NotificationPage = class {
  static selectors = selectors_default5;
  selectors = selectors_default5;
  page;
  constructor(page) {
    this.page = page;
  }
  async connectToDapp(extensionId, accounts) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await connectToDapp(notificationPage, accounts);
  }
  // TODO: Revisit this logic in the future to see if we can increase the performance by utilizing `Promise.race`.
  async beforeMessageSignature(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    const isScrollButtonVisible = await waitFor(
      () => notificationPage.locator(selectors_default5.SignaturePage.structuredMessage.scrollDownButton).isVisible(),
      1500,
      false
    );
    return {
      notificationPage,
      isScrollButtonVisible
    };
  }
  async signMessage(extensionId) {
    const { notificationPage, isScrollButtonVisible } = await this.beforeMessageSignature(extensionId);
    if (isScrollButtonVisible) {
      await signStructuredMessage.sign(notificationPage);
    } else {
      await signSimpleMessage.sign(notificationPage);
    }
  }
  async rejectMessage(extensionId) {
    const { notificationPage, isScrollButtonVisible } = await this.beforeMessageSignature(extensionId);
    if (isScrollButtonVisible) {
      await signStructuredMessage.reject(notificationPage);
    } else {
      await signSimpleMessage.reject(notificationPage);
    }
  }
  async approveNewNetwork(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await network.approveNewNetwork(notificationPage);
  }
  async rejectNewNetwork(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await network.rejectNewNetwork(notificationPage);
  }
  async approveSwitchNetwork(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await network.approveSwitchNetwork(notificationPage);
  }
  async rejectSwitchNetwork(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await network.rejectSwitchNetwork(notificationPage);
  }
  async confirmTransaction(extensionId, options) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await transaction.confirm(notificationPage, options?.gasSetting ?? "site");
  }
  async rejectTransaction(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await transaction.reject(notificationPage);
  }
  async confirmTransactionAndWaitForMining(extensionId, options) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await transaction.confirmAndWaitForMining(this.page, notificationPage, options?.gasSetting ?? "site");
  }
  async approveTokenPermission(extensionId, options) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    if (options?.spendLimit !== void 0) {
      await approvePermission.editTokenPermission(notificationPage, options.spendLimit);
    }
    await approvePermission.approve(notificationPage, options?.gasSetting ?? "site");
  }
  async rejectTokenPermission(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await approvePermission.reject(notificationPage);
  }
};

// src/metamask.ts
var NO_EXTENSION_ID_ERROR = new Error("MetaMask extensionId is not set");
var MetaMask = class {
  /**
   * Class constructor.
   *
   * @param context - The browser context.
   * @param page - The MetaMask tab page.
   * @param password - The password of the MetaMask wallet.
   * @param extensionId - The extension ID of the MetaMask extension. Optional if no interaction with the dapp is required.
   *
   * @returns A new instance of the MetaMask class.
   */
  constructor(context, page, password, extensionId) {
    this.context = context;
    this.page = page;
    this.password = password;
    this.extensionId = extensionId;
    this.crashPage = new CrashPage();
    this.onboardingPage = new OnboardingPage(page);
    this.lockPage = new LockPage(page);
    this.homePage = new HomePage(page);
    this.notificationPage = new NotificationPage(page);
  }
  /**
   * This property can be used to access selectors for a given page.
   *
   * @group Selectors
   */
  crashPage;
  /**
   * This property can be used to access selectors for a given page.
   *
   * @group Selectors
   */
  onboardingPage;
  /**
   * This property can be used to access selectors for a given page.
   *
   * @group Selectors
   */
  lockPage;
  /**
   * This property can be used to access selectors for a given page.
   *
   * @group Selectors
   */
  homePage;
  /**
   * This property can be used to access selectors for a given page.
   *
   * @group Selectors
   */
  notificationPage;
  /**
   * Imports a wallet using the given seed phrase.
   *
   * @param seedPhrase - The seed phrase to import.
   */
  async importWallet(seedPhrase) {
    await this.onboardingPage.importWallet(seedPhrase, this.password);
  }
  /**
   * Adds a new account with the given name. This account is based on the initially imported seed phrase.
   *
   * @param accountName - The name of the new account.
   */
  async addNewAccount(accountName) {
    await this.homePage.addNewAccount(accountName);
  }
  /**
   * Imports a wallet using the given private key.
   *
   * @param privateKey - The private key to import.
   */
  async importWalletFromPrivateKey(privateKey) {
    await this.homePage.importWalletFromPrivateKey(privateKey);
  }
  /**
   * Switches to the account with the given name.
   *
   * @param accountName - The name of the account to switch to.
   */
  async switchAccount(accountName) {
    await this.homePage.switchAccount(accountName);
  }
  /**
   * Adds a new network.
   *
   * @param network - The network object to use for adding the new network.
   * @param network.name - The name of the network.
   * @param network.rpcUrl - The RPC URL of the network.
   * @param network.chainId - The chain ID of the network.
   * @param network.symbol - The currency symbol of the network.
   * @param network.blockExplorerUrl - The block explorer URL of the network.
   */
  async addNetwork(network2) {
    await this.homePage.addNetwork(network2);
  }
  /**
   * Switches to the network with the given name.
   *
   * @param networkName - The name of the network to switch to.
   * @param isTestnet - If switch to a test network.
   */
  async switchNetwork(networkName, isTestnet = false) {
    await this.homePage.switchNetwork(networkName, isTestnet);
  }
  /**
   * Connects to the dapp using the currently selected account.
   */
  async connectToDapp(accounts) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.connectToDapp(this.extensionId, accounts);
  }
  /**
   * Locks MetaMask.
   */
  async lock() {
    await this.homePage.lock();
  }
  /**
   * Unlocks MetaMask.
   */
  async unlock() {
    await this.lockPage.unlock(this.password);
  }
  /**
   * Confirms a signature request. This function supports all types of commonly used signatures.
   */
  async confirmSignature() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.signMessage(this.extensionId);
  }
  /**
   * Rejects a signature request. This function supports all types of commonly used signatures.
   */
  async rejectSignature() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectMessage(this.extensionId);
  }
  /**
   * Approves a new network request.
   */
  async approveNewNetwork() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.approveNewNetwork(this.extensionId);
  }
  /**
   * Rejects a new network request.
   */
  async rejectNewNetwork() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectNewNetwork(this.extensionId);
  }
  /**
   * Approves a switch network request.
   */
  async approveSwitchNetwork() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.approveSwitchNetwork(this.extensionId);
  }
  /**
   * Rejects a switch network request.
   */
  async rejectSwitchNetwork() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectSwitchNetwork(this.extensionId);
  }
  /**
   * Confirms a transaction request.
   *
   * @param options - The transaction options.
   * @param options.gasSetting - The gas setting to use for the transaction.
   */
  async confirmTransaction(options) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.confirmTransaction(this.extensionId, options);
  }
  /**
   * Rejects a transaction request.
   */
  async rejectTransaction() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectTransaction(this.extensionId);
  }
  /**
   * Approves a permission request to spend tokens.
   *
   * ::: warning
   * For NFT approvals, use `confirmTransaction` method.
   * :::
   *
   * @param options - The permission options.
   * @param options.spendLimit - The spend limit to use for the permission.
   * @param options.gasSetting - The gas setting to use for the approval transaction.
   */
  async approveTokenPermission(options) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.approveTokenPermission(this.extensionId, options);
  }
  /**
   * Rejects a permission request to spend tokens.
   *
   * ::: warning
   * For NFT approvals, use `confirmTransaction` method.
   * :::
   */
  async rejectTokenPermission() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectTokenPermission(this.extensionId);
  }
  /**
   * Goes back to the home page of MetaMask tab.
   */
  async goBackToHomePage() {
    await this.homePage.goBackToHomePage();
  }
  /**
   * Opens the settings page.
   */
  async openSettings() {
    await this.homePage.openSettings();
  }
  /**
   * Opens a given menu in the sidebar.
   *
   * @param menu - The menu to open.
   */
  async openSidebarMenu(menu) {
    await this.homePage.openSidebarMenu(menu);
  }
  /**
   * Toggles the "Show Test Networks" setting.
   *
   * ::: warning
   * This function requires the correct menu to be already opened.
   * :::
   */
  async toggleShowTestNetworks() {
    await this.homePage.toggleShowTestNetworks();
  }
  /**
   * Toggles the "Dismiss Secret Recovery Phrase Reminder" setting.
   *
   * ::: warning
   * This function requires the correct menu to be already opened.
   * :::
   */
  async toggleDismissSecretRecoveryPhraseReminder() {
    await this.homePage.toggleDismissSecretRecoveryPhraseReminder();
  }
  /**
   * Resets the account.
   *
   * ::: warning
   * This function requires the correct menu to be already opened.
   * :::
   */
  async resetAccount() {
    await this.homePage.resetAccount();
  }
  /// -------------------------------------------
  /// ---------- EXPERIMENTAL FEATURES ----------
  /// -------------------------------------------
  /**
   * Confirms a transaction request and waits for the transaction to be mined.
   * This function utilizes the "Activity" tab of the MetaMask tab.
   *
   * @param options - The transaction options.
   * @param options.gasSetting - The gas setting to use for the transaction.
   *
   * @experimental
   * @group Experimental Methods
   */
  async confirmTransactionAndWaitForMining(options) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.confirmTransactionAndWaitForMining(this.extensionId, options);
  }
  /**
   * Opens the transaction details.
   *
   * @param txIndex - The index of the transaction in the "Activity" tab. Starts from `0`.
   *
   * @experimental
   * @group Experimental Methods
   */
  async openTransactionDetails(txIndex) {
    await this.homePage.openTransactionDetails(txIndex);
  }
  /**
   * Closes the currently opened transaction details.
   *
   * @experimental
   * @group Experimental Methods
   */
  async closeTransactionDetails() {
    await this.homePage.closeTransactionDetails();
  }
};
async function unlockForFixture(page, password) {
  const metamask = new MetaMask(page.context(), page, password);
  await unlockWalletButReloadIfSpinnerDoesNotVanish(metamask);
  await retryIfMetaMaskCrashAfterUnlock(page);
  await closePopover(page);
  await closeRecoveryPhraseReminder(page);
}
async function unlockWalletButReloadIfSpinnerDoesNotVanish(metamask) {
  try {
    await metamask.unlock();
  } catch (e) {
    if (e instanceof errors.TimeoutError) {
      console.warn("[UnlockWalletButReloadIfSpinnerDoesNotVanish] Unlocking MetaMask timed out. Reloading page...");
      const page = metamask.page;
      await page.reload();
      await waitForSpinnerToVanish(page);
    } else {
      throw e;
    }
  }
}
async function retryIfMetaMaskCrashAfterUnlock(page) {
  const homePageLogoLocator = page.locator(HomePage.selectors.logo);
  const isHomePageLogoVisible = await homePageLogoLocator.isVisible();
  const isPopoverVisible = await page.locator(HomePage.selectors.popover.closeButton).isVisible();
  if (!isHomePageLogoVisible && !isPopoverVisible) {
    if (await page.locator(CrashPage.selectors.header).isVisible()) {
      const errors$1 = await page.locator(CrashPage.selectors.errors).allTextContents();
      console.warn(["[RetryIfMetaMaskCrashAfterUnlock] MetaMask crashed due to:", ...errors$1].join("\n"));
      console.log("[RetryIfMetaMaskCrashAfterUnlock] Reloading page...");
      await page.reload();
      try {
        await homePageLogoLocator.waitFor({
          state: "visible",
          timeout: 1e4
          // TODO: Extract & Make this timeout configurable.
        });
        console.log("[RetryIfMetaMaskCrashAfterUnlock] Successfully restored MetaMask!");
      } catch (e) {
        if (e instanceof errors.TimeoutError) {
          throw new Error(
            ["[RetryIfMetaMaskCrashAfterUnlock] Reload did not help. Throwing with the crash cause:", ...errors$1].join(
              "\n"
            )
          );
        }
        throw e;
      }
    }
  }
}

export { MetaMask, unlockForFixture };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map