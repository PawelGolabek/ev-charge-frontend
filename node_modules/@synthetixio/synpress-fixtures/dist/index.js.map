{"version":3,"sources":["../src/fixtures/testWithSynpress.ts","../src/utils/getExtensionId.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'node:path'\nimport type {\n  Fixtures,\n  Page,\n  PlaywrightTestArgs,\n  PlaywrightTestOptions,\n  PlaywrightWorkerArgs,\n  PlaywrightWorkerOptions\n} from '@playwright/test'\nimport { chromium, test as base } from '@playwright/test'\nimport { defineWalletSetup } from '@synthetixio/synpress-core'\nimport { createTempContextDir, removeTempContextDir } from '@synthetixio/synpress-core'\nimport { CACHE_DIR_NAME, prepareExtension } from '@synthetixio/synpress-core'\nimport { type Anvil, type CreateAnvilOptions, createPool } from '@viem/anvil'\nimport fs from 'fs-extra'\nimport { getExtensionId } from '../utils/getExtensionId'\n\ntype UnlockWalletFunction = (walletPage: Page, password: string) => Promise<void>\n\n// Base types of the `test` fixture from Playwright.\ntype TestFixtures = PlaywrightTestArgs & PlaywrightTestOptions\ntype WorkerFixtures = PlaywrightWorkerArgs & PlaywrightWorkerOptions\n\ntype PrivateSynpressFixtures = {\n  _contextPath: string\n}\n\ntype PublicSynpressFixtures = {\n  extensionId: string\n  metamaskPage: Page\n  createAnvilNode: (options?: CreateAnvilOptions) => Promise<{ anvil: Anvil; rpcUrl: string; chainId: number }>\n}\n\ntype SynpressFixtures = TestFixtures & PrivateSynpressFixtures & PublicSynpressFixtures\n\n// TODO: Bad practice. Use a store!\nlet _metamaskPage: Page\n\nconst synpressFixtures = (\n  walletSetup: ReturnType<typeof defineWalletSetup>,\n  unlockWallet: UnlockWalletFunction,\n  slowMo = 0\n): Fixtures<SynpressFixtures, WorkerFixtures> => ({\n  _contextPath: async ({ browserName }, use, testInfo) => {\n    const contextPath = await createTempContextDir(browserName, testInfo.testId)\n\n    await use(contextPath)\n\n    const error = await removeTempContextDir(contextPath)\n    if (error) {\n      console.error(error)\n    }\n  },\n  context: async ({ context: _, _contextPath }, use) => {\n    const cacheDirPath = path.join(process.cwd(), CACHE_DIR_NAME, walletSetup.hash)\n    if (!(await fs.exists(cacheDirPath))) {\n      throw new Error(`Cache for ${walletSetup.hash} does not exist. Create it first!`)\n    }\n\n    // Copying the cache to the temporary context directory.\n    await fs.copy(cacheDirPath, _contextPath)\n\n    const metamaskPath = await prepareExtension()\n\n    // We don't need the `--load-extension` arg since the extension is already loaded in the cache.\n    const browserArgs = [`--disable-extensions-except=${metamaskPath}`]\n\n    if (process.env.HEADLESS) {\n      browserArgs.push('--headless=new')\n\n      if (slowMo > 0) {\n        console.warn('[WARNING] Slow motion makes no sense in headless mode. It will be ignored!')\n      }\n    }\n\n    const context = await chromium.launchPersistentContext(_contextPath, {\n      headless: false,\n      args: browserArgs,\n      slowMo: process.env.HEADLESS ? 0 : slowMo\n    })\n\n    // TODO: This should be stored in a store to speed up the tests.\n    const extensionId = await getExtensionId(context, 'MetaMask')\n\n    // TODO: Not sure if this is the best approach. Time will tell.\n    // We're utilizing the blank page here.\n    _metamaskPage = context.pages()[0] as Page\n\n    await _metamaskPage.goto(`chrome-extension://${extensionId}/home.html`)\n\n    await _metamaskPage.reload()\n\n    await unlockWallet(_metamaskPage, walletSetup.walletPassword)\n\n    await use(context)\n\n    await context.close()\n  },\n  extensionId: async ({ context }, use) => {\n    const extensionId = await getExtensionId(context, 'MetaMask')\n\n    await use(extensionId)\n  },\n  metamaskPage: async ({ context: _ }, use) => {\n    await use(_metamaskPage)\n  },\n  // TODO: We should be able to use this in a wallet setup. This will be possible when we add a store.\n  // TODO: ^ Thanks to this we won't have to rely on MetaMask RPC for initial connection, which will increase the speed of the tests.\n  createAnvilNode: async ({ context: _ }, use) => {\n    const pool = createPool()\n\n    await use(async (options?: CreateAnvilOptions) => {\n      const nodeId = Array.from(pool.instances()).length\n      const anvil = await pool.start(nodeId, options)\n\n      const rpcUrl = `http://${anvil.host}:${anvil.port}`\n\n      const DEFAULT_ANVIL_CHAIN_ID = 31337\n      const chainId = options?.chainId ?? DEFAULT_ANVIL_CHAIN_ID\n\n      return { anvil, rpcUrl, chainId }\n    })\n\n    await pool.empty()\n  }\n})\n\n/**\n *  The factory function for the `test` fixture from Playwright extended with Synpress fixtures.\n *\n * @param walletSetup - An object returned from the `defineWalletSetup` function.\n * @param walletSetup.hash - Hash of the cached wallet setup function.\n * @param walletSetup.fn - The wallet setup function itself.\n * @param walletSetup.walletPassword - The password of the wallet.\n * @param unlockWallet - A function that unlocks the wallet.\n * @param slowMo - Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to `0`.\n *\n * @returns The `test` fixture from Playwright extended with Synpress fixtures. See: https://playwright.dev/docs/api/class-test#test-call.\n */\nexport const testWithSynpress = (\n  walletSetup: ReturnType<typeof defineWalletSetup>,\n  unlockWallet: UnlockWalletFunction,\n  slowMo?: number\n) => {\n  // biome-ignore lint/suspicious/noExplicitAny: satisfying TypeScript here - this type doesn't matter since we are overriding it\n  return base.extend<PublicSynpressFixtures>(synpressFixtures(walletSetup, unlockWallet, slowMo) as any)\n}\n","import type { BrowserContext } from '@playwright/test'\nimport { z } from 'zod'\n\nconst Extension = z.object({\n  id: z.string(),\n  name: z.string()\n})\n\nconst Extensions = z.array(Extension)\n\n/**\n * Returns the extension ID for the given extension name. The ID is fetched from the `chrome://extensions` page.\n *\n * ::: tip\n * This function soon will be removed to improve the developer experience! ðŸ˜‡\n * :::\n *\n * @param context - The browser context.\n * @param extensionName - The name of the extension, e.g., `MetaMask`.\n *\n * @returns The extension ID.\n */\nexport async function getExtensionId(context: BrowserContext, extensionName: string) {\n  const page = await context.newPage()\n  await page.goto('chrome://extensions')\n\n  const unparsedExtensions = await page.evaluate('chrome.management.getAll()')\n\n  const allExtensions = Extensions.parse(unparsedExtensions)\n  const targetExtension = allExtensions.find(\n    (extension) => extension.name.toLowerCase() === extensionName.toLowerCase()\n  )\n\n  if (!targetExtension) {\n    throw new Error(\n      [\n        `[GetExtensionId] Extension with name ${extensionName} not found.`,\n        `Available extensions: ${allExtensions.map((extension) => extension.name).join(', ')}`\n      ].join('\\n')\n    )\n  }\n\n  await page.close()\n\n  return targetExtension.id\n}\n"]}