import path from 'path';
import { test, chromium } from '@playwright/test';
import { createTempContextDir, removeTempContextDir, CACHE_DIR_NAME, prepareExtension } from '@synthetixio/synpress-core';
import { createPool } from '@viem/anvil';
import fs from 'fs-extra';
import { z } from 'zod';

// src/fixtures/testWithSynpress.ts
var Extension = z.object({
  id: z.string(),
  name: z.string()
});
var Extensions = z.array(Extension);
async function getExtensionId(context, extensionName) {
  const page = await context.newPage();
  await page.goto("chrome://extensions");
  const unparsedExtensions = await page.evaluate("chrome.management.getAll()");
  const allExtensions = Extensions.parse(unparsedExtensions);
  const targetExtension = allExtensions.find(
    (extension) => extension.name.toLowerCase() === extensionName.toLowerCase()
  );
  if (!targetExtension) {
    throw new Error(
      [
        `[GetExtensionId] Extension with name ${extensionName} not found.`,
        `Available extensions: ${allExtensions.map((extension) => extension.name).join(", ")}`
      ].join("\n")
    );
  }
  await page.close();
  return targetExtension.id;
}

// src/fixtures/testWithSynpress.ts
var _metamaskPage;
var synpressFixtures = (walletSetup, unlockWallet, slowMo = 0) => ({
  _contextPath: async ({ browserName }, use, testInfo) => {
    const contextPath = await createTempContextDir(browserName, testInfo.testId);
    await use(contextPath);
    const error = await removeTempContextDir(contextPath);
    if (error) {
      console.error(error);
    }
  },
  context: async ({ context: _, _contextPath }, use) => {
    const cacheDirPath = path.join(process.cwd(), CACHE_DIR_NAME, walletSetup.hash);
    if (!await fs.exists(cacheDirPath)) {
      throw new Error(`Cache for ${walletSetup.hash} does not exist. Create it first!`);
    }
    await fs.copy(cacheDirPath, _contextPath);
    const metamaskPath = await prepareExtension();
    const browserArgs = [`--disable-extensions-except=${metamaskPath}`];
    if (process.env.HEADLESS) {
      browserArgs.push("--headless=new");
      if (slowMo > 0) {
        console.warn("[WARNING] Slow motion makes no sense in headless mode. It will be ignored!");
      }
    }
    const context = await chromium.launchPersistentContext(_contextPath, {
      headless: false,
      args: browserArgs,
      slowMo: process.env.HEADLESS ? 0 : slowMo
    });
    const extensionId = await getExtensionId(context, "MetaMask");
    _metamaskPage = context.pages()[0];
    await _metamaskPage.goto(`chrome-extension://${extensionId}/home.html`);
    await _metamaskPage.reload();
    await unlockWallet(_metamaskPage, walletSetup.walletPassword);
    await use(context);
    await context.close();
  },
  extensionId: async ({ context }, use) => {
    const extensionId = await getExtensionId(context, "MetaMask");
    await use(extensionId);
  },
  metamaskPage: async ({ context: _ }, use) => {
    await use(_metamaskPage);
  },
  // TODO: We should be able to use this in a wallet setup. This will be possible when we add a store.
  // TODO: ^ Thanks to this we won't have to rely on MetaMask RPC for initial connection, which will increase the speed of the tests.
  createAnvilNode: async ({ context: _ }, use) => {
    const pool = createPool();
    await use(async (options) => {
      const nodeId = Array.from(pool.instances()).length;
      const anvil = await pool.start(nodeId, options);
      const rpcUrl = `http://${anvil.host}:${anvil.port}`;
      const DEFAULT_ANVIL_CHAIN_ID = 31337;
      const chainId = options?.chainId ?? DEFAULT_ANVIL_CHAIN_ID;
      return { anvil, rpcUrl, chainId };
    });
    await pool.empty();
  }
});
var testWithSynpress = (walletSetup, unlockWallet, slowMo) => {
  return test.extend(synpressFixtures(walletSetup, unlockWallet, slowMo));
};

export { getExtensionId, testWithSynpress };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map